
import {MCED} from "../../lib/constants.mjs"; //Importing here!

export function installMCGenerator(pythonGenerator,Order) {
    // Set the standard Python indent to 4 spaces
    pythonGenerator.INDENT = '    ';

     /**
     * Initializes the generator by clearing the custom methods cache.
     * This is called by Blockly before code generation begins.
     */
    // --- CORRECT, ROBUST WAY TO EXTEND a generator method ---

    // 1. Store the original init function from the pythonGenerator prototype.
    const originalInit = pythonGenerator.init;

    // 2. Create a new init function that calls the original and adds our logic.
    pythonGenerator.init = function(workspace) {
        // First, call the original init function. This is CRUCIAL.
        // It sets up core features like the name database (nameDB_).
        originalInit.call(this, workspace);

        // Now, add our custom initialization for tracking user-defined methods.
        // We can be sure that 'this' refers to the generator instance.
        this.methods_ = Object.create(null);
    };

    /**
     * Finalize the code by wrapping it in the BlocklyProgramRunner class,
     * prepending any user-defined methods.
     */

    // === THE CORRECTED finish FUNCTION ===
    pythonGenerator.finish = function(code) {
        // 'code' is the main execution flow for run_program()

        // --- 1. Get all definitions (functions) collected during the run ---
        const definitions = Object.values(pythonGenerator.methods_ || {});

        // --- 2. Prepare Imports and Timestamp ---
        const now = new Date();
        const timestamp = now.toISOString();

        // --- 3. Prepare the indented code blocks ---
        // Indent the user-defined methods to fit inside the class
        const userDefinedMethods = definitions.length > 0
            ? '\n' + definitions
                // Use the generator's prefixLines utility, which correctly handles indentation.
                // We indent each entire method definition by one level (e.g., 2 spaces).
                .map(methodDef => pythonGenerator.prefixLines(methodDef, pythonGenerator.INDENT))
                .join('\n')
            : '';

        // Indent the main execution code for the run_program method.
        // It needs to be indented by two levels (e.g., 4 spaces).
        const indentedBlockCode = pythonGenerator.prefixLines(code, pythonGenerator.INDENT + pythonGenerator.INDENT) || (pythonGenerator.INDENT + pythonGenerator.INDENT + 'pass  # No blocks in program');


        // --- 4. Assemble the final script using the correct structure ---
        const finalScript = `
# Generated by Blockly MC-ED on ${timestamp}
from mcshell.constants import *

class BlocklyProgramRunner:
    def __init__(self, action_implementer_instance):
        self.action_implementer = action_implementer_instance

${userDefinedMethods}

    def run_program(self):
${indentedBlockCode}

`;
        return finalScript.trim() + '\n';
    };

    // --- Generators for Function Definition and Call Blocks ---
    // (These now correctly use generator.methods_ which is initialized by pythonGenerator.init)

    pythonGenerator.forBlock['procedures_defnoreturn'] = function(block, generator) {
        const funcName = generator.nameDB_.getName(
            block.getFieldValue('NAME'), MCED.BlocklyNameTypes.PROCEDURE);
        // `statementToCode` will indent the body with generator.INDENT (e.g., 2 spaces)
        let branch = generator.statementToCode(block, 'STACK') || (generator.INDENT + 'pass\n');

        const args = [];
        const variables = block.getVars();
        for (let i = 0; i < variables.length; i++) {
            args.push(generator.nameDB_.getName(variables[i], MCED.BlocklyNameTypes.VARIABLE));
        }
        // Create the method string. The `def` line has NO indent.
        // The `branch` is already indented one level.
        let code = 'def ' + funcName + '(self' + (args.length ? ', ' : '') + args.join(', ') + '):\n' + branch;

        if (!generator.methods_) generator.methods_ = {};
        generator.methods_['%' + funcName] = code;
        return null;
    };

    pythonGenerator.forBlock['procedures_defreturn'] = function(block, generator) {
        const funcName = generator.nameDB_.getName(
            block.getFieldValue('NAME'), MCED.BlocklyNameTypes.PROCEDURE);
        let branch = generator.statementToCode(block, 'STACK');
        let returnValue = generator.valueToCode(block, 'RETURN', generator.ORDER_NONE) || 'None';

        const returnStatement = generator.INDENT + 'return ' + returnValue + '\n';
        branch = branch ? branch + returnStatement : returnStatement;

        const args = [];
        const variables = block.getVars();
        for (let i = 0; i < variables.length; i++) {
            args.push(generator.nameDB_.getName(variables[i], MCED.BlocklyNameTypes.VARIABLE));
        }
        let code = 'def ' + funcName + '(self' + (args.length ? ', ' : '') + args.join(', ') + '):\n' + branch;

        if (!generator.methods_) generator.methods_ = {};
        generator.methods_['%' + funcName] = code;
        return null;
    };

    pythonGenerator.forBlock['procedures_callnoreturn'] = function(block, generator) {
        const funcName = generator.nameDB_.getName(block.getFieldValue('NAME'), MCED.BlocklyNameTypes.PROCEDURE);
        const args = [];
        const variables = block.getVars();
        for (let i = 0; i < variables.length; i++) {
            args.push(generator.valueToCode(block, 'ARG' + i, generator.ORDER_NONE) || 'None');
        }
        const code = 'self.' + funcName + '(' + args.join(', ') + ')\n';
        return code;
    };

    pythonGenerator.forBlock['procedures_callreturn'] = function(block, generator) {
        const funcName = generator.nameDB_.getName(block.getFieldValue('NAME'), MCED.BlocklyNameTypes.PROCEDURE);
        const args = [];
        const variables = block.getVars();
        for (let i = 0; i < variables.length; i++) {
            args.push(generator.valueToCode(block, 'ARG' + i, generator.ORDER_NONE) || 'None');
        }
        const code = 'self.' + funcName + '(' + args.join(', ') + ')';
        return [code, generator.ORDER_FUNCTION_CALL];
    };

    // The 'procedures_ifreturn' generator does not use getPythonName and should be fine as is.
    // --- Generator for Conditional Return (if you use it) ---
    pythonGenerator.forBlock['procedures_ifreturn'] = function(block, generator) {
        // Conditionally return a value from a procedure.
        const condition = generator.valueToCode(block, 'CONDITION', generator.ORDER_NONE) || 'False';
        let code = 'if ' + condition + ':\n';
        if (block.hasReturnValue_) {
            const value = generator.valueToCode(block, 'VALUE', generator.ORDER_NONE) || 'None';
            code += generator.INDENT + 'return ' + value + '\n';
        } else {
            code += generator.INDENT + 'return\n';
        }
        return code;
    };

    pythonGenerator.forBlock['minecraft_matrix_3d_elements'] = function(block, generator) {
        const r00 = generator.valueToCode(block, 'R00', generator.ORDER_ATOMIC) || '1.0';
        const r01 = generator.valueToCode(block, 'R01', generator.ORDER_ATOMIC) || '0.0';
        const r02 = generator.valueToCode(block, 'R02', generator.ORDER_ATOMIC) || '0.0';
        const r10 = generator.valueToCode(block, 'R10', generator.ORDER_ATOMIC) || '0.0';
        const r11 = generator.valueToCode(block, 'R11', generator.ORDER_ATOMIC) || '1.0';
        const r12 = generator.valueToCode(block, 'R12', generator.ORDER_ATOMIC) || '0.0';
        const r20 = generator.valueToCode(block, 'R20', generator.ORDER_ATOMIC) || '0.0';
        const r21 = generator.valueToCode(block, 'R21', generator.ORDER_ATOMIC) || '0.0';
        const r22 = generator.valueToCode(block, 'R22', generator.ORDER_ATOMIC) || '1.0';

        const code = `Matrix3([[${r00}, ${r01}, ${r02}], [${r10}, ${r11}, ${r12}], [${r20}, ${r21}, ${r22}]])`;
        return [code, generator.ORDER_FUNCTION_CALL];
    };

    pythonGenerator.forBlock['minecraft_matrix_3d_euler'] = function(block, generator) {
        const yaw = generator.valueToCode(block, 'YAW', generator.ORDER_ATOMIC) || '0.0';
        const pitch = generator.valueToCode(block, 'PITCH', generator.ORDER_ATOMIC) || '0.0';
        const roll = generator.valueToCode(block, 'ROLL', generator.ORDER_ATOMIC) || '0.0';

        const code = `Matrix3.from_euler_angles(yaw_degrees=${yaw}, pitch_degrees=${pitch}, roll_degrees=${roll})`;
        return [code, generator.ORDER_FUNCTION_CALL];
    };

    pythonGenerator.forBlock['minecraft_vector_2d'] = function(block, generator) {
        const w = block.getFieldValue('W') || '0'; // Get directly from FieldNumber
        const h = block.getFieldValue('H') || '0';
        const code = `(${w}, ${h})`; // Generates a Python tuple string
        return [code, generator.ORDER_ATOMIC];
    };

    pythonGenerator.forBlock['minecraft_vector_3d'] = function (block,generator) {
        const xValue = block.getFieldValue('X');
        const yValue = block.getFieldValue('Y');
        const zValue = block.getFieldValue('Z');

       let code = `Vec3(${xValue},${yValue},${zValue})`
       return [code,Order.ATOMIC];
    }

    pythonGenerator.forBlock['minecraft_vector_delta'] = function (block,generator) {
        const xValue = block.getFieldValue('X');
        const yValue = block.getFieldValue('Y');
        const zValue = block.getFieldValue('Z');

        let code = `Vec3(${xValue},${yValue},${zValue})`
        return [code,Order.ATOMIC];
    }

    pythonGenerator.forBlock['minecraft_position_get_direction'] = function (block,generator) {
        let code = `self.action_implementer.mcplayer.direction`
        return [code,Order.ATOMIC];
    }

    pythonGenerator.forBlock['minecraft_position_player'] = function (block,generator) {
        let code = `self.action_implementer.mcplayer.position`
        return [code,Order.ATOMIC];
    }

    pythonGenerator.forBlock['minecraft_position_here'] = function (block,generator) {
        let code = `self.action_implementer.mcplayer.here`
        return [code,Order.ATOMIC];
    }

    pythonGenerator.forBlock['minecraft_vector_arithmetic'] = function(block, generator) {
        const operator = block.getFieldValue('OP');
        let order, code;

        if (operator === 'MATRIX_MULTIPLY') {
            // Matrix multiplication: matrix @ vector
            const matrix = generator.valueToCode(block, 'A', generator.ORDER_ATOMIC) || 'Matrix3.identity()';
            const vector = generator.valueToCode(block, 'B', generator.ORDER_ATOMIC) || 'Vec3()';
            order = generator.ORDER_MULTIPLICATIVE; // The @ operator has the same precedence as *
            code = `${matrix} @ ${vector}`;
        } else if (operator === 'MULTIPLY') {
            // Scalar multiplication: vector * number
            const vector = generator.valueToCode(block, 'A', generator.ORDER_MULTIPLICATIVE) || 'Vec3()';
            const scalar = generator.valueToCode(block, 'B', generator.ORDER_MULTIPLICATIVE) || '1';
            order = generator.ORDER_MULTIPLICATIVE;
            code = `${vector} * ${scalar}`;
        } else if (operator === 'DOT') {
            // Dot product: vector.dot(vector)
            const vector1 = generator.valueToCode(block, 'A', generator.ORDER_ATOMIC) || 'Vec3()';
            const vector2 = generator.valueToCode(block, 'B', generator.ORDER_ATOMIC) || 'Vec3()';
            order = generator.ORDER_FUNCTION_CALL;
            code = `${vector1}.dot(${vector2})`;
        } else if (operator === 'CROSS') {
            // Cross product: vector.cross(vector)
            const vector1 = generator.valueToCode(block, 'A', generator.ORDER_ATOMIC) || 'Vec3()';
            const vector2 = generator.valueToCode(block, 'B', generator.ORDER_ATOMIC) || 'Vec3()';
            order = generator.ORDER_FUNCTION_CALL;
            code = `${vector1}.cross(${vector2})`;
        } else { // ADD or SUBTRACT
            const OPERATORS = {
                'ADD': [' + ', generator.ORDER_ADDITIVE],
                'SUBTRACT': [' - ', generator.ORDER_ADDITIVE],
            };
            const tuple = OPERATORS[operator];
            const op_str = tuple[0];
            order = tuple[1];
            const vector1 = generator.valueToCode(block, 'A', order) || 'Vec3()';
            const vector2 = generator.valueToCode(block, 'B', order) || 'Vec3()';
            code = `${vector1}${op_str}${vector2}`;
        }

        return [code, order];
    };

    pythonGenerator.forBlock['minecraft_coloured_block_picker'] = function(block, generator) {
      const colourId = block.getFieldValue('MINECRAFT_COLOUR_ID'); // e.g., "WHITE", "RED"
      // The Python code should return a representation that your MCPlayerActions can understand.
      // This could be the ID string itself, or you might map it to a specific
      // Minecraft block ID or data value here.
      // For now, let's just return the ID string.
      return [`'${colourId}'`, generator.ORDER_ATOMIC];
    };

    // --Digital Geometry

    pythonGenerator.forBlock['minecraft_action_create_digital_ball'] = function(block, generator) {
        const center = generator.valueToCode(block, 'CENTER', generator.ORDER_ATOMIC) || "Vec3(0,0,0)";
        const radius = generator.valueToCode(block, 'RADIUS', generator.ORDER_ATOMIC) || "5.0";
        const blockType = generator.valueToCode(block, 'BLOCK_TYPE', generator.ORDER_ATOMIC) || "'STONE'";
        const innerRadius = generator.valueToCode(block, 'INNER_RADIUS', generator.ORDER_ATOMIC) || "0.0";

        return `self.action_implementer.create_digital_ball(center_vec3=${center}, radius=${radius}, block_type=${blockType}, inner_radius=${innerRadius})\n`;
    };

    pythonGenerator.forBlock['minecraft_action_create_digital_cube'] = function(block, generator) {
        const center = generator.valueToCode(block, 'CENTER', generator.ORDER_ATOMIC) || "Vec3(0,0,0)";
        const sideLength = generator.valueToCode(block, 'SIDE_LENGTH', generator.ORDER_ATOMIC) || "5.0";
        const rotationMatrix = generator.valueToCode(block, 'ROTATION_MATRIX', generator.ORDER_ATOMIC) || "Matrix3.identity()"; // Default to identity matrix
        const blockType = generator.valueToCode(block, 'BLOCK_TYPE', generator.ORDER_ATOMIC) || "'STONE'";
        const innerOffsetFactor = generator.valueToCode(block, 'INNER_OFFSET_FACTOR', generator.ORDER_ATOMIC) || "0.0";

        return `self.action_implementer.create_digital_cube(center_vec3=${center}, side_length=${sideLength}, rotation_matrix3=${rotationMatrix}, block_type=${blockType}, inner_offset_factor=${innerOffsetFactor})\n`;
    };

    pythonGenerator.forBlock['minecraft_action_create_digital_plane'] = function(block, generator) {
        const normal = generator.valueToCode(block, 'NORMAL', generator.ORDER_ATOMIC) || "Vec3(0,1,0)";
        const pointOnPlane = generator.valueToCode(block, 'POINT_ON_PLANE', generator.ORDER_ATOMIC) || "Vec3(0,0,0)";
        const blockType = generator.valueToCode(block, 'BLOCK_TYPE', generator.ORDER_ATOMIC) || "'STONE'";
        const outerRectDims = generator.valueToCode(block, 'OUTER_RECT_DIMS', generator.ORDER_ATOMIC) || "(10, 10)"; // Default tuple if not connected
        const planeThickness = generator.valueToCode(block, 'PLANE_THICKNESS', generator.ORDER_ATOMIC) || "1.0";
        const innerRectDims = generator.valueToCode(block, 'INNER_RECT_DIMS', generator.ORDER_ATOMIC) || "None"; // Python None if not connected
        const rectCenterOffset = generator.valueToCode(block, 'RECT_CENTER_OFFSET', generator.ORDER_ATOMIC) || "Vec3(0,0,0)";

        return `self.action_implementer.create_digital_plane(` +
               `normal_vec3=${normal}, point_on_plane_vec3=${pointOnPlane}, block_type=${blockType}, ` +
               `outer_rect_dims_tuple=${outerRectDims}, plane_thickness=${planeThickness}, ` +
               `inner_rect_dims_tuple=${innerRectDims}, rect_center_offset_vec3=${rectCenterOffset})\n`;
    };

    pythonGenerator.forBlock['minecraft_action_create_digital_disc'] = function(block, generator) {
        const normal = generator.valueToCode(block, 'NORMAL', generator.ORDER_ATOMIC) || "Vec3(0,1,0)";
        const centerPoint = generator.valueToCode(block, 'CENTER_POINT', generator.ORDER_ATOMIC) || "Vec3(0,0,0)";
        const outerRadius = generator.valueToCode(block, 'OUTER_RADIUS', generator.ORDER_ATOMIC) || "10.0";
        const blockType = generator.valueToCode(block, 'BLOCK_TYPE', generator.ORDER_ATOMIC) || "'STONE'";
        const discThickness = generator.valueToCode(block, 'DISC_THICKNESS', generator.ORDER_ATOMIC) || "1.0";
        const innerRadius = generator.valueToCode(block, 'INNER_RADIUS', generator.ORDER_ATOMIC) || "0.0";

        return `self.action_implementer.create_digital_disc(` +
               `normal_vec3=${normal}, center_point_vec3=${centerPoint}, outer_radius=${outerRadius}, ` +
               `block_type=${blockType}, disc_thickness=${discThickness}, inner_radius=${innerRadius})\n`;
    };

    pythonGenerator.forBlock['minecraft_action_create_digital_tube'] = function(block, generator) {
        const point1 = generator.valueToCode(block, 'POINT1', generator.ORDER_ATOMIC) || "Vec3(0,0,0)";
        const point2 = generator.valueToCode(block, 'POINT2', generator.ORDER_ATOMIC) || "Vec3(0,10,0)";
        const outerThickness = generator.valueToCode(block, 'OUTER_THICKNESS', generator.ORDER_ATOMIC) || "3.0";
        const blockType = generator.valueToCode(block, 'BLOCK_TYPE', generator.ORDER_ATOMIC) || "'STONE'";
        const innerThickness = generator.valueToCode(block, 'INNER_THICKNESS', generator.ORDER_ATOMIC) || "0.0";

        // Construct the Python code string using keyword arguments for clarity
        return `self.action_implementer.create_digital_tube(` +
               `point1_vec3=${point1}, point2_vec3=${point2}, ` +
               `outer_thickness=${outerThickness}, block_type=${blockType}, ` +
               `inner_thickness=${innerThickness})\n`;
    };

    pythonGenerator.forBlock['minecraft_action_create_digital_line'] = function(block, generator) {
        const point1 = generator.valueToCode(block, 'POINT1', generator.ORDER_ATOMIC) || "Vec3(0,0,0)";
        const point2 = generator.valueToCode(block, 'POINT2', generator.ORDER_ATOMIC) || "Vec3(10,10,10)";
        const blockType = generator.valueToCode(block, 'BLOCK_TYPE', generator.ORDER_ATOMIC) || "'STONE'";

        // Construct the Python code string using keyword arguments
        return `self.action_implementer.create_digital_line(point1_vec3=${point1}, point2_vec3=${point2}, block_type=${blockType})\n`;
    };



    pythonGenerator.forBlock['minecraft_action_spawn_entity'] = function(block, generator) {
        // Get the code for the connected value inputs, with defaults
        const entityType = generator.valueToCode(block, 'ENTITY_TYPE', generator.ORDER_ATOMIC) || "'PIG'";
        const position = generator.valueToCode(block, 'POSITION', generator.ORDER_ATOMIC) || "Vec3(0, 0, 0)";

        // Construct the Python code string using keyword arguments
        const code = `self.action_implementer.spawn_entity(position_vec3=${position}, entity_type=${entityType})\n`;

        return code;
    };
}